var documenterSearchIndex = {"docs":
[{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"Author = \"Thomas Christensen\"","category":"page"},{"location":"operations/#Symmetry-operations","page":"Symmetry operations","title":"Symmetry operations","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"A SymOperation{D} is a representation of a spatial symmetry operation g=Ww, composed of a rotational W and a translation part w. The rotational and translation parts are assumed to share the same basis system; by default, operations returned by tools in Crystalline.jl will return operations in the conventional setting of International Tables of Crystallography, Volume A (ITA).","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"SymOperations can be constructed in two ways, either by explicitly specifying the W and w:","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"using Crystalline, StaticArrays\nW, w = (@SMatrix [1 0 0; 0 0 1; 0 1 0]), (@SVector [0, 0.5, 0])\nop = SymOperation(W, w)","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"or by its equivalent triplet form","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"op = SymOperation{3}(\"x,z+1/2,y\")","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"There is also a string macro accessor @S_str that allows triplet input via S\"x,z+1/2,y\".","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"In the above output, three equivalent notations for the symmetry operation are given: first, the Seitz notation {m₀₋₁₁|0,½,0}, then the triplet notation (x,z+1/2,y), and finally the explicit matrix notation.","category":"page"},{"location":"operations/#Components","page":"Symmetry operations","title":"Components","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"The rotation and translation parts W and w of a SymOperation{D} Ww can be accessed via rotation and translation,  returning an SMatrix{D, D, Float64} and an SVector{D, Float64}, respectively. The \"augmented\" matrix Ww can similarly be obtained via matrix.","category":"page"},{"location":"operations/#Operator-composition","page":"Symmetry operations","title":"Operator composition","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"Composition of two operators g_1 and g_2 is defined by ","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"g_1 circ g_2 = W_1w_1 circ W_2w_2 = W_1W_2w_1 + W_1w_2","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"We can compose two SymOperations in Crystalline via:","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"op1 = S\"z,x,y\" # 3₁₁₁⁺\nop2 = S\"z,y,x\" # m₋₁₀₁\nop1 ∘ op2","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"Note that composition is taken modulo integer lattice translations by default, such that","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"op2′ = S\"z,y,x+1\" # {m₋₁₀₁|001}\nop1 ∘ op2′ # equivalent to compose(op1, op2′, true)","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"rather than S\"x+1,z,y\", which is the result of direct application of the above composition rule. To compute \"unreduced\" composition, the alternative compose variant of ∘ can be used with an optional third argument false:","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"compose(op1, op2′, false)","category":"page"},{"location":"operations/#Operator-inverses","page":"Symmetry operations","title":"Operator inverses","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"The operator inverse is defined as Ww = W^-1-W^-1w and can be computed via","category":"page"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"inv(op1) # inv(3₁₁₁⁺)","category":"page"},{"location":"operations/#Action-of-symmetry-operators","page":"Symmetry operations","title":"Action of symmetry operators","text":"","category":"section"},{"location":"operations/","page":"Symmetry operations","title":"Symmetry operations","text":"TODO.","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"CurrentModule = Crystalline","category":"page"},{"location":"api/#Exported-types","page":"API","title":"Exported types","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = false\nOrder   = [:type]","category":"page"},{"location":"api/#Crystalline.BandRep","page":"API","title":"Crystalline.BandRep","text":"struct BandRep <: AbstractArray{Int64,1}\n\nwyckpos::String\nsitesym::String\nlabel::String\ndim::Int64\ndecomposable::Bool\nspinful::Bool\nirvec::Array{Int64,1}\nirlabs::Array{String,1}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.BandRepSet","page":"API","title":"Crystalline.BandRepSet","text":"struct BandRepSet <: AbstractArray{BandRep,1}\n\nsgnum::Int64\nbandreps::Array{BandRep,1}\nkvs::Array{var\"#s62\",1} where var\"#s62\"<:KVec\nklabs::Array{String,1}\nirlabs::Array{String,1}\nallpaths::Bool\nspinful::Bool\ntimeinvar::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.CharacterTable","page":"API","title":"Crystalline.CharacterTable","text":"struct CharacterTable{D}\n\nops::Array{SymOperation{D},1} where D\nirlabs::Array{String,1}\nchartable::Array{Complex{Float64},2}\ntag::String\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.CharacterTable-Union{Tuple{AbstractArray{var\"#s12\",1} where var\"#s12\"<:Crystalline.AbstractIrrep{D}}, Tuple{D}, Tuple{AbstractArray{var\"#s61\",1} where var\"#s61\"<:Crystalline.AbstractIrrep{D},Union{Nothing, AbstractArray{var\"#s62\",1} where var\"#s62\"<:Real}}} where D","page":"API","title":"Crystalline.CharacterTable","text":"CharacterTable(irs::AbstractVector{<:AbstractIrrep}, αβγ=nothing)\n\nReturns a CharacterTable associated with vector of AbstractIrreps irs. \n\nOptionally, an αβγ::AbstractVector{<:Real} variable can be passed to evaluate the irrep (and associated characters) with concrete free parameters (e.g., for LGIrreps, a concrete k-vector sampled from a \"line-irrep\"). Defaults to nothing, indicating it being either  irrelevant (e.g., for PGIrreps) or all free parameters implicitly set to zero.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.DirectBasis","page":"API","title":"Crystalline.DirectBasis","text":"DirectBasis{D} <: Basis{D}\n\nvecs::NTuple{D, SVector{D, Float64}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.KVec-Union{Tuple{AbstractString}, Tuple{D}} where D","page":"API","title":"Crystalline.KVec","text":"KVec{D}(str::AbstractString) --> KVec{D}\nKVec(str::AbstractString)    --> KVec\nKVec(::AbstractVector, ::AbstractMatrix) --> KVec\n\nReturn a KVec by parsing the string representations str, supplied in one of the following formats:\n\n\"($1,$2,$3)\"\n\"[$1,$2,$3]\"\n\"$1,$2,$3\"\n\nwhere the coordinates $1,$2, and $3 are strings that may contain fractions, decimal numbers, and \"free\" parameters {'α','β','γ'} (or, alternatively and equivalently, {'u','v','w'} or {'x','y','z'}).\n\nFractions such as 1/2 and decimal numbers can be parsed: but use of any other special operator besides / will produce undefined behavior (e.g. do not use *).\n\nExample\n\njulia> KVec(\"0.25,α,0\")\n[0.25, α, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.LGIrrep","page":"API","title":"Crystalline.LGIrrep","text":"struct LGIrrep{D} <: Crystalline.AbstractIrrep{D}\n\ncdml::String\ng::LittleGroup{D} where D\nmatrices::Array{Array{Complex{Float64},2},1}\ntranslations::Array{Array{Float64,1},1}\nreality::Reality\niscorep::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.LittleGroup","page":"API","title":"Crystalline.LittleGroup","text":"struct LittleGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\nkv::KVec{D} where D\nklab::String\noperations::Array{SymOperation{D},1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.ModulatedFourierLattice","page":"API","title":"Crystalline.ModulatedFourierLattice","text":"ModulatedFourierLattice{D} <: AbstractFourierLattice{D}\n\nA D-dimensional concrete Fourier/plane wave lattice, derived from  a UnityFourierLattice by scaling/modulating its orbit coefficients  by complex numbers; in general, the coefficients do not have unit norm.\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.MultTable","page":"API","title":"Crystalline.MultTable","text":"struct MultTable{D} <: AbstractArray{Int64,2}\n\noperations::Array{SymOperation{D},1} where D\ntable::Array{Int64,2}\nisgroup::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.MultTable-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.MultTable","text":"MultTable(ops::AbstractVector{<:SymOperation{D}}, modτ=true, verbose=false)\n\nCompute the multiplication (or Cayley) table of ops, an AbstractVector of SymOperation{D}s. The modτ keyword argument controls whether composition of operations is taken modulo lattice vectors (true, default) or not (false).\n\nA MultTable{D} is returned, which contains symmetry operations resulting from composition  of row ∘ col operators; the table of indices give the symmetry operators relative to the ordering of ops.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.PGIrrep","page":"API","title":"Crystalline.PGIrrep","text":"struct PGIrrep{D} <: Crystalline.AbstractIrrep{D}\n\ncdml::String\ng::PointGroup{D} where D\nmatrices::Array{Array{Complex{Float64},2},1}\nreality::Reality\niscorep::Bool\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.PointGroup","page":"API","title":"Crystalline.PointGroup","text":"struct PointGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\nlabel::String\noperations::Array{SymOperation{D},1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.RVec-Union{Tuple{AbstractString}, Tuple{D}} where D","page":"API","title":"Crystalline.RVec","text":"RVec{D}(str::AbstractString) --> RVec{D}\nRVec(str::AbstractString)    --> RVec\nRVec(::AbstractVector, ::AbstractMatrix) --> RVec\n\nReturn a RVec by parsing the string representations str, supplied in one of the following formats:\n\n\"($1,$2,$3)\"\n\"[$1,$2,$3]\"\n\"$1,$2,$3\"\n\nwhere the coordinates $1,$2, and $3 are strings that may contain fractions, decimal numbers, and \"free\" parameters {'α','β','γ'} (or, alternatively and equivalently, {'u','v','w'} or {'x','y','z'}).\n\nFractions such as 1/2 and decimal numbers can be parsed: but use of any other special operator besides / will produce undefined behavior (e.g. do not use *).\n\nExample\n\njulia> RVec(\"0.25,α,0\")\n[0.25, α, 0.0]\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.Reality","page":"API","title":"Crystalline.Reality","text":"Reality <: Enum{Int8}\n\nEnum type with instances\n\nREAL = 1\nPSEUDOREAL = -1\nCOMPLEX = 0\n\nThe return value of reality(::AbstractIrrep) and calc_reality is an instance of Reality. The reality type of an irrep is relevant for constructing \"physically real\" irreps (co-reps) via realify.\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.ReciprocalBasis","page":"API","title":"Crystalline.ReciprocalBasis","text":"ReciprocalBasis{D} <: Basis{D}\n\nvecs::NTuple{D, SVector{D, Float64}}\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.SiteGroup-Union{Tuple{D}, Tuple{SpaceGroup{D},WyckPos{D}}} where D","page":"API","title":"Crystalline.SiteGroup","text":"SiteGroup(sg::SpaceGroup{D}, wp::WyckPos{D}) -> SiteGroup{_A} where _A\n\n\nReturn the site symmetry group g::SiteGroup for a Wyckoff position wp in space group sg (or with space group number sgnum; in this case, the dimensionality is inferred from wp).\n\ng is a group of operations that are isomorphic to the those listed in sg (in the sense that they might differ by lattice vectors) and that leave the Wyckoff position wp invariant, such that all(op -> wp == op∘wp, g) is true.\n\nThe returned SiteGroup also contains the coset representatives of the Wyckoff position (that are again isomorphic to those featured in sg), accessible via cosets, which \\eg generate the orbit of the Wyckoff position (see orbit(::SiteGroup, ::WyckPos)) and define a left-coset decomposition of sg jointly with the elements in g.\n\nExample\n\njulia> sgnum = 16; D = 2;\n\njulia> wp = get_wycks(sgnum, D)[3] # pick a Wyckoff position\n2b: [0.3333333333333333, 0.6666666666666666]\n\njulia> sg = spacegroup(sgnum, D);\n\njulia> g  = SiteGroup(sg, wp)\nSiteGroup{2} #16 at 2b = [0.333333, 0.666667] with 3 operations:\n 1 ────────────────────────────────── (x,y)\n {3⁺|1,1} ──────────────────── (-y+1,x-y+1)\n {3⁻|0,1} ───────────────────── (-x+y,-x+1)\n\nThe group structure of a SiteGroup can be inspected with MultTable:\n\njulia> MultTable(g)\n3×3 MultTable{2}:\n──────────┬──────────────────────────────\n          │        1  {3⁺|1,1}  {3⁻|0,1} \n──────────┼──────────────────────────────\n        1 │        1  {3⁺|1,1}  {3⁻|0,1} \n {3⁺|1,1} │ {3⁺|1,1}  {3⁻|0,1}         1\n {3⁻|0,1} │ {3⁻|0,1}         1  {3⁺|1,1}\n──────────┴──────────────────────────────\n\nThe original space group can be reconstructed from a left-coset decomposition, using the operations and cosets contained in a SiteGroup:\n\njulia> ops = [opʰ∘opᵍ for opʰ in cosets(g) for opᵍ in g];\n\njulia> Set(sg) == Set(ops)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.SpaceGroup","page":"API","title":"Crystalline.SpaceGroup","text":"struct SpaceGroup{D} <: Crystalline.AbstractGroup{D}\n\nnum::Int64\noperations::Array{SymOperation{D},1} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Crystalline.SymOperation","page":"API","title":"Crystalline.SymOperation","text":"struct SymOperation{D} <: AbstractArray{Float64,2}\n\nrotation::Crystalline.SquareStaticMatrices.SqSMatrix{D,Float64} where D\ntranslation::StaticArrays.SArray{Tuple{D},Float64,1,D} where D\n\n\n\n\n\n","category":"type"},{"location":"api/#Exported-methods","page":"API","title":"Exported methods","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = false\nOrder   = [:function]","category":"page"},{"location":"api/#Crystalline.bandreps","page":"API","title":"Crystalline.bandreps","text":"bandreps(sgnum::Integer, D::Integer=3; \n         allpaths::Bool=false, spinful::Bool=false, timereversal::Bool=true)\n\nReturns the BandRepSet for space group sgnum (provided by the Bilbao Crystallographic Server) and dimension D.\n\nKeyword arguments:\n\nallpaths: include a minimal sufficient set (false, default) or all (true) k-vectors. \nspinful: single- (false, default) or double-valued (true) irreps, as appropriate for            spinless and spinful particles, respectively.\ntimereversal: assume presence (true, default) or absence (false) of time-reversal                 symmetry.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.basisdim-Tuple{BandRepSet}","page":"API","title":"Crystalline.basisdim","text":"basisdim(BRS::BandRepSet) --> Int64\n\nComputes the dimension of the (linearly independent parts) of a band representation set. This is d^textbs = d^textai in the notation of Po, Watanabe, & Vishwanath, Nature Commun. 8, 50 (2017). In other words, this is the number of linearly independent basis vectors that span the expansions of a band structure or atomic insulator viewed as symmetry-data.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.calc_reality-Union{Tuple{D}, Tuple{LGIrrep{D},AbstractArray{SymOperation{D},1}}, Tuple{LGIrrep{D},AbstractArray{SymOperation{D},1},Union{Nothing, Array{var\"#s139\",1} where var\"#s139\"<:Real}}} where D","page":"API","title":"Crystalline.calc_reality","text":"calc_reality(lgir::LGIrrep, \n             sgops::AbstractVector{SymOperation{D}},\n             αβγ::Union{Vector{<:Real},Nothing}=nothing) --> ::(Enum Reality)\n\nCompute and return the reality of a lgir::LGIrrep using the Herring criterion.\n\nThe computed value is one of three integers in 1-10. In practice, this value is returned via a member of the Enum Reality, which has instances REAL = 1, PSEUDOREAL = -1, and COMPLEX = 0.\n\nOptional arguments\n\nAs a sanity check, a value of αβγ can be provided to check for invariance along a symmetry symmetry line/plane/general point in k-space. The reality must be invariant to this choice.\n\nNote\n\nThe provided space group operations sgops must be the set reduced by primitive translation vectors; i.e. using spacegroup(...) directly is not allowable in general (since the irreps we reference only include these \"reduced\" operations). This reduced set of operations can be obtained e.g. from the Γ point irreps of ISOTROPY's dataset, or alternatively, from reduce_ops(spacegroup(...), true).\n\nImplementation\n\nThe Herring criterion evaluates the following sum\n\n χ(βb²)g_0M(k)\n\nover symmetry operations βb that take k  -k. Here g_0 is the order of the point group of the space group and M(k) is the order of star(k) [both in a primitive basis].\n\nSee e.g. Cornwell, p. 150-152 & 187-188 (which we mainly followed), Inui Eq. (13.48),  Dresselhaus, p. 618, or Herring's original paper.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.calcfourier-Tuple{Any,Crystalline.AbstractFourierLattice}","page":"API","title":"Crystalline.calcfourier","text":"calcfourier(xyz, flat::AbstractFourierLattice) --> Float64\n\nCompute the real part of the function evaluation of flat at a point xyz (a tuple, SVector, or a vector), i.e. return     Re[∑ᵢ cᵢexp(2πi𝐆ᵢ⋅𝐫)] with 𝐆ᵢ denoting a 𝐆-vector in an allowed orbit in flat, and  cᵢ an associated coefficient (and with 𝐫 ≡ xyz).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.cartesianize-Union{Tuple{D}, Tuple{SymOperation{D},DirectBasis{D}}} where D","page":"API","title":"Crystalline.cartesianize","text":"cartesianize(op::SymOperation{D}, Rs::DirectBasis{D}) --> SymOperation{D}\n\nConverts opˡ from a lattice basis to a Cartesian basis, by computing the transformed operators opᶜ = 𝐑*opˡ*𝐑⁻¹ via the Cartesian basis matrix 𝐑 (whose columns are the DirectBasis vectors Rs[i]). \n\nNote 1\n\nThe matrix 𝐑 maps vectors coefficients in a lattice basis 𝐯ˡ to coefficients in a Cartesian basis 𝐯ᶜ as 𝐯ˡ = 𝐑⁻¹𝐯ᶜ and vice versa as 𝐯ᶜ = 𝐑𝐯ˡ. Since a general transformation P  transforms an \"original\" vectors with coefficients 𝐯 to new coefficients 𝐯′ via 𝐯′ = P⁻¹𝐯 and since we here here consider the lattice basis as the \"original\" basis we have P = 𝐑⁻¹.  As such, the transformation of the operator op transforms as opᶜ = P⁻¹*opˡ*P, i.e. opᶜ = transform(opˡ,P) = transform(opˡ,𝐑⁻¹).\n\nNote 2\n\nThe display (e.g. Seitz and xyzt notation) of SymOperations e.g. in the REPL implicitly assumes integer coefficients for its point-group matrix: as a consequence, displaying  SymOperations in a Cartesian basis may produce undefined behavior. The matrix representation remains valid, however.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.centering","page":"API","title":"Crystalline.centering","text":"centering(sg::SpaceGroup) --> Char\ncentering(sgnum::Integer, D::Integer=3) --> Char\n\nDetermines the conventional centering type of a given space/plane group sg (alternatively specified by its conventional number sgnum and dimensionality D by comparison with the Hermann-Mauguin notation's first letter. \n\nPossible output values, depending on dimensionality D, are (see ITA Sec. 9.1.4):\n\nD=2 ┌ 'p': no centring (primitive)\n    └ 'c': face centered\n\nD=3 ┌ 'P': no centring (primitive)\n    ├ 'I': body centred (innenzentriert)\n    ├ 'F': all-face centred\n    ├ 'A', 'B', 'C': one-face centred, (b,c) or (c,a) or (a,b)\n    └ 'R': hexagonal cell rhombohedrally centred\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.classification-Tuple{BandRepSet}","page":"API","title":"Crystalline.classification","text":"classification(BRS::BandRepSet) --> String\n\nCalculate the symmetry indicator classification of a band representation set, meaning the  index-classification inferrable on the basis of symmetry alone.\n\nTechnically, the calculation answers a question like \"what direct product of  mathbbZ_n groups is the the quotient group X^textbs = textBStextAI isomorphic to?\".\n\nSee e.g. Po, Watanabe, & Vishwanath, Nature Commun. 8, 50 (2017) for more information.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D","page":"API","title":"Crystalline.conventionalize","text":"conventionalize(flat′::AbstractFourierLattice, cntr::Char) --> ::typeof(flat′)\n\nGiven flat′ referred to a primitive basis with centering cntr, compute the derived (but physically equivalent) lattice flat referred to the associated conventional basis. \n\nSee also the complementary methods transform(::AbstractFourierLattice, ::AbstractMatrix{<:Real}) and primitivize(::AbstractFourierLattice, ::Char) for additional details.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.conventionalize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D},Char}} where D","page":"API","title":"Crystalline.conventionalize","text":"conventionalize(v′::T, cntr::Char) where T<:AbstractVec{D} --> v::T\n\nTransforms a primitive coordinate vector v′ back to a standard conventional basis (specified by the centering type cntr), returning the conventional coordinate vector v.\n\nSee also primitivize(::AbstractVec, ::Char and transform.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.conventionalize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D","page":"API","title":"Crystalline.conventionalize","text":"conventionalize(Rs′::DirectBasis, cntr::Char) --> Rs::DirectBasis\n\nTransforms a primitive DirectBasis Rs′ into its conventional equivalent Rs, with the  transformation dependent on the centering type cntr (P, I, F, R, A, C, and p, c); for centering P and p, the conventional and primive bases coincide.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.cosets-Tuple{SiteGroup}","page":"API","title":"Crystalline.cosets","text":"cosets(g::SiteGroup) -> Array{SymOperation{D},1} where D\n\n\nReturn the cosets of a SiteGroup g.\n\nThe cosets generate the orbit of the Wyckoff position wyck(g) (see  orbit(::SiteGroup, ::WyckPos)) and furnish a left-coset decomposition of the underlying space group, jointly with the operations in g itself.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.crystal-NTuple{6,Real}","page":"API","title":"Crystalline.crystal","text":"crystal(a,b,c,α,β,γ) --> Rs::DirectBasis{3}\n\nCalculate basis vectors mathbfR_1, mathbfR_2, mathbfR_3 in a 3D Cartesian basis for a right-handed coordinate system with specified basis vector lengths a, b, c (associated with mathbfR_1, mathbfR_2, & mathbfR_3, respectively) and specified interaxial angles  α = (mathbfR_2mathbfR_3), β = (mathbfR_3mathbfR_1),  γ = (mathbfR_1mathbfR_2), with  denoting the angle between two vectors.\n\nFor definiteness, the mathbfR_1 basis vector is oriented along the x-axis of the Cartesian coordinate system, and the mathbfR_2 axis is placed in the xy-plane.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.crystal-Tuple{Real,Real,Real}","page":"API","title":"Crystalline.crystal","text":"crystal(a,b,γ) --> DirectBasis{2}\n\nCalculate basis vectors mathbfR_1, mathbfR_2 in a 2D Cartesian basis for a  right-handed coordinate system with specified basis vector lengths a, b (associated with mathbfR_1 & mathbfR_2, respectively) and specified interaxial angle γ = (mathbfR_1mathbfR_2).\n\nFor definiteness, the mathbfR_1 basis vector is oriented along the x-axis of the Cartesian coordinate system.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.crystal-Tuple{Real}","page":"API","title":"Crystalline.crystal","text":"crystal(a)  --> DirectBasis{1}\n\nReturn a one-dimensional crystal with lattice period a.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.crystalsystem-Union{Tuple{DirectBasis{D}}, Tuple{D}} where D","page":"API","title":"Crystalline.crystalsystem","text":"crystalsystem(R::DirectBasis{D})\n\nDetermine the crystal system of a point lattice specified in a  conventional DirectBasis{D} of dimension D using Tables 2.1.2.1, 9.1.7.1, & 9.1.7.2 of the International Tables of  Crystallography, Volume 1 (ITA).  There are 4 crystal systems in 2D and 7 in 3D (see ITA 2.1.2(iii)):\n\nD System Conditions Free parameters\n1D linear none a\n2D square a=b & γ=90° a\n rectangular γ=90° a,b\n hexagonal a=b & γ=120° a\n oblique none a,b,γ\n3D cubic a=b=c & α=β=γ=90° a\n hexagonal a=b & α=β=90° & γ=120° a,c\n trigonal a=b & α=β=90° & γ=120° a,c (a,α for hR)\n tetragonal a=b & α=β=γ=90° a,c\n orthorhombic α=β=γ=90° a,b,c\n monoclinic α=γ=90° a,b,c,β≥90°\n triclinic none a,b,c,α,β,γ\n\nThe DirectBasis input is assumed to use conventional basis vectors;  i.e. not necessarily primitive. For primitive basis vectors, the  crystal system can be further reduced into 5 Bravais types in 2D and 14 in 3D.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.dim-Tuple{BandRep}","page":"API","title":"Crystalline.dim","text":"dim(BR::BandRep) --> Int\n\nGet the number of bands included in a single BandRep BR; i.e. the \"band filling\" ν discussed in Po's papers.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.directbasis-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D","page":"API","title":"Crystalline.directbasis","text":"directbasis(sgnum, D=3;    abclims, αβγlims)\ndirectbasis(sgnum, Val(D); abclims, αβγlims) --> DirectBasis{D}\n\nGenerates a (conventional) DirectBasis for a crystal compatible with  the space group number sgnum and dimensionality D. Free parameters in the lattice vectors are chosen randomly, with limits optionally supplied in abclims (lengths) and αβγlims (angles). By convention, the length of the first lattice vector (= a) is set to unity, such that the second and third (= b and c) lattice  vectors' lengths are relative to the first.\n\nLimits on the relative uniform distribution of lengths b and c can be specified as 2-tuple kwarg abclims; similarly, limits on  the angles α, β, γ can be set via αβγlims (only affects  oblique, monoclinic, & triclinic lattices).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.find_isomorphic_parent_pointgroup-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.find_isomorphic_parent_pointgroup","text":"find_isomorphic_parent_pointgroup(g::AbstractVector{SymOperation{D}}) \n                                                --> PointGroup{D}, Vector{Int}, Bool\n\nGiven a group g (or a collection of operators, defining a group), identifies a \"parent\" point group that is isomorphic to g.\n\nThree variables are returned:\n\npg: the identified \"parent\" point group, with operators sorted to match the sorting of g's operators.\nIᵖ²ᵍ: a permutation vector which transforms the standard sorting of point group operations (as returned by pointgroup(::String)) to the operator sorting of g.\nequal: a boolean, identifying whether the point group parts of g operations are identical (true) or merely isomorphic to the point group operations in g. In practice, this indicates whether pg and g are in the same setting or not.\n\nImplementation\n\nThe identification is made partly on the basis of comparison of operators (this is is sufficient for the equal = true case) and partly on the basis of comparison of  multiplication tables (equal = false case); the latter can be combinatorially slow if the sorting of operators is unlucky (i.e., if permutation between sortings in g and pg differ by many pairwise permutations).\n\nBeyond mere isomorphisms of multiplication tables, the search also guarantees that all rotation orders are shared between pg and g. This disambiguates point groups that are intrinsically isomorphic to eachother, e.g. \"m\" and \"-1\", but which still differ in their spatial interpretation.\n\nProperties\n\nThe following properties hold for g, pg, and Iᵖ²ᵍ:\n\npg, Iᵖ²ᵍ, equal = find_isomorphic_parent_pointgroup(g)\n@assert MultTable(pg) == MultTable(pointgroup(g))\npg′ = pointgroup(label(pg), dim(pg)) # \"standard\" sorting\n@assert pg′[Iᵖ²ᵍ] == pg\n\nIf equal = true, the following also holds:\n\npointgroup(g) == operations(pg) == operations(pg′)[Iᵖ²ᵍ]\n\nExample\n\nsgnum = 141\nwp    = get_wycks(sgnum, Val(3))[end] # 4a Wyckoff position\nsg    = spacegroup(sgnum, Val(3))\nsiteg = SiteGroup(sg, wp)\npg, Iᵖ²ᵍ, equal = find_isomorphic_parent_pointgroup(siteg)\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.find_representation","page":"API","title":"Crystalline.find_representation","text":"find_representation(symvals::AbstractVector{Number}, \n                    lgirs::AbstractVector{<:AbstractIrrep},\n                    αβγ::Union{AbstractVector{<:Real},Nothing}=nothing,\n                    assert_return_T::Type{<:Union{Integer, AbstractFloat}}=Int))\n\n                    --> Vector{assert_return_T}\n\nFrom a vector (or vector of vectors) of symmetry eigenvalues symvals sampled along all the operations of a group gᵢ, whose irreps are contained in irs (evaluated with optional free  parameters αβγ), return the multiplicities of each irrep.\n\nOptionally, the multiciplities' element type can be specified via the assert_return_T argument (performing checked conversion; returns nothing if representation in  assert_return_T is impossible). This can be useful if one suspects a particular band to  transform like a fraction of an irrep (i.e., the specified symmetry data is incomplete).\n\nExtended help\n\nEffectively, this applies the projection operator P⁽ʲ⁾ of each irrep's character set χ⁽ʲ⁾(gᵢ) (j = 1, ... , Nⁱʳʳ) to the symmetry data sᵢ ≡ symvals:\n\nP⁽ʲ⁾  ≡ (dⱼ/|g|) ∑ᵢ χ⁽ʲ⁾(gᵢ)*gᵢ         [characters χ⁽ʲ⁾(gᵢ), irrep dimension dⱼ]\nP⁽ʲ⁾s = (dⱼ/|g|) ∑ᵢ χ⁽ʲ⁾(gᵢ)*sᵢ = nⱼ,   [number of bands that transform like jth irrep]\n\nreturning the irrep multiplicities mⱼ ≡ nⱼ/dⱼ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.findmaximal-Union{Tuple{AbstractArray{SiteGroup{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.findmaximal","text":"findmaximal(sitegs::AbstractVector{<:SiteGroup})\n\nGiven a vector of SiteGroups associated with the Wyckoff positions of a space group, return those SiteGroups that are associated with a maximal Wyckoff positions.\n\nResults are returned as a view into the input vector (i.e. as an  AbstractVector{<:SiteGroup}). The associated Wyckoff positions can subsequently be retrieved via wyck.\n\nDefinition\n\nA Wyckoff position is maximal if its site symmetry group has higher order than the site symmetry groups of any \"nearby\" Wyckoff positions (i.e. Wyckoff positions that can be  connected, i.e. made equivalent, through parameter variation to the considered Wyckoff position).\n\nExample\n\njulia> sgnum = 5; D = 2;\njulia> wps = get_wycks(sgnum, Val(D));\njulia> sg  = spacegroup(sgnum, Val(D));\n\njulia> sitegs = SiteGroup.(Ref(sg), wps)\nSiteGroup{2} #5 at 4b = [α, β] with 1 operations:\n 1 ────────────────────────────────── (x,y)\nSiteGroup{2} #5 at 2a = [0.0, β] with 2 operations:\n 1 ────────────────────────────────── (x,y)\n m₁₀ ─────────────────────────────── (-x,y)\n\njulia> findmaximal(sitegs)\nSiteGroup{2} #5 at 2a = [0.0, β] with 2 operations:\n 1 ────────────────────────────────── (x,y)\n m₁₀ ─────────────────────────────── (-x,y)\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.generate-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.generate","text":"generate(gens::AbstractArray{SymOperation{D},1}; modτ, Nmax) -> Crystalline.GenericGroup{_A} where _A\n\n\nGenerate a group from a finite set of generators gens. Returns a GenericGroup.\n\nKeyword arguments\n\nmodτ (default, true): the group composition operation can either be taken modulo lattice vectors (true) or not (false, useful e.g. for site symmetry groups). In this case, the provided generators will also be taken modulo integer lattice translations.\nNmax (default, 256): the maximum size of the generated group. This is essentially a cutoff set to ensure halting of execution in case the provided set of generators do not define a finite group (especially relevant if modτ=false). If more operations than Nmax are generated, the method throws an overflow error.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.get_lgirreps-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},JLD2.JLDFile}, Tuple{Integer,Val{D},JLD2.JLDFile,JLD2.JLDFile}} where D","page":"API","title":"Crystalline.get_lgirreps","text":"get_lgirreps(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3))\n                                                -> Dict{String, Vector{LGIrrep{D}}}\n\nFor given space group number sgnum and dimension D, return the associated little group (or \"small\") irreps (LGIrrep{D}s) at high-symmetry k-points, lines, and planes. \n\nReturns a Dict with little group k-point labels as keys and vectors of LGIrrep{D}s as values.\n\nNotes\n\nCurrently, only D = 3 is supported.\nThe returned irreps are complex in general. Real irreps (as needed in time-reversal invariant settings) can subsequently be obtained with the realify method.\nReturned irreps are spinless.\n\nReferences\n\nThe underlying data is sourced from the ISOTROPY ISO-IR dataset. Please cite original reference material associated with ISO-IR:\n\n[1] Stokes, Hatch, & Campbell, ISO-IR, ISOTROPY Software Suite [2] Stokes, Campbell, & Cordes, Acta Cryst. A. 69, 388-395 (2013).\n\nThe ISO-IR dataset is occasionally missing some k-points that lie outside the basic domain but still resides in the representation domain (i.e. k-points with postscripted 'A', 'B', etc. labels, such as 'ZA'). In such cases, the missing irreps may instead have been manually sourced from the Bilbao Crystallographic Database.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.get_littlegroups-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}, Tuple{Integer,Val{D},JLD2.JLDFile}} where D","page":"API","title":"Crystalline.get_littlegroups","text":"get_littegroups(sgnum::Integer, D::Union{Val{Int}, Integer}=Val(3)) \n                                                    -> Dict{String, LittleGroup{D}}\n\nFor given space group number sgnum and dimension D, return the associated little groups (LittleGroups{D}s) at high-symmetry k-points, lines, and planes (see also get_lgirreps).\n\nReturns a Dict with little group k-point labels as keys and vectors of LittleGroup{D}s as values.\n\nNotes\n\nA conventional crystallographic setting is assumed (as in spacegroup).\n\nUnlike spacegroup, \"centering\"-copies of symmetry operations are not included in the returned LittleGroups; as an example, space group 110 (body-centered, with centering symbol 'I') has a centering translation [1/2,1/2,1/2] in the conventional setting: the symmetry operations returned by spacegroup thus includes e.g. both {1|0} and  {1|½,½,½} while the symmetry operations returned by get_littlegroups only include {1|0} (and so on).\n\nCurrently, only D = 3 is supported.\n\nReferences\n\nThe underlying data is sourced from the ISOTROPY dataset: see also get_lgirreps.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.get_pgirreps","page":"API","title":"Crystalline.get_pgirreps","text":"get_pgirreps(iuclab::String, ::Val{D}=Val(3)) where D ∈ (1,2,3)\nget_pgirreps(iuclab::String, D)\n\nReturn the (crystallographic) point group irreps of the IUC label iuclab of dimension D as a vector of PGIrrep{D}s.\n\nNotes\n\nThe irrep labelling follows the conventions of CDML [1] [which occasionally differ from those in e.g. Bradley and Cracknell, The Mathematical Theory of Symmetry in Solids  (1972)]. For associated Mulliken (\"spectroscopist\") notation, see mulliken.\n\nThe data is sourced from the Bilbao Crystallographic Server [2]. If you are using this  functionality in an explicit fashion, please cite the original reference [3].\n\nReferences\n\n[1] Cracknell, Davies, Miller, & Love, Kronecher Product Tables 1 (1979).\n\n[2] Bilbao Crystallographic Server:       https://www.cryst.ehu.es/cgi-bin/cryst/programs/representations_point.pl\n\n[3] Elcoro et al.,       J. of Appl. Cryst. 50, 1457 (2017)\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.get_wycks-Union{Tuple{D}, Tuple{Integer,Val{D}}} where D","page":"API","title":"Crystalline.get_wycks","text":"get_wycks(sgnum::Integer, _::Val{D}) -> Any\n\n\nReturn the Wyckoff positions of space group sgnum in dimension D as a  Vector{WyckPos{D}.\n\nThe positions are given in the conventional basis setting, following the conventions of the Bilbao Crystallographic Server (from which the underlying data is sourced [1]).\n\nExample\n\njulia> wps = get_wycks(16, 2)\n4-element Array{WyckPos{2},1}:\n 6d: [α, β]\n 3c: [0.5, 0.0]\n 2b: [0.3333333333333333, 0.6666666666666666]\n 1a: [0.0, 0.0]\n\nReferences\n\n[1] Aroyo, et. al. Zeitschrift fuer Kristallographie (2006), 221, 1, 15-27.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.isnormal-Union{Tuple{T}, Tuple{T,T}} where T<:(AbstractArray{var\"#s18\",1} where var\"#s18\"<:(SymOperation{var\"#s17\"} where var\"#s17\"))","page":"API","title":"Crystalline.isnormal","text":"isnormal(opsᴳ::T, opsᴴ::T; verbose::Bool=false) where T<:AbstractVector{SymOperation{D}}\n                                                --> Bool\n\nDetermine whether the operations in group H are normal in the group G (each with  operations opsᴳ and opsᴴ), in the sense that \n\nghg¹  H  gG  hH\n\nReturns a Boolean answer (true if normal, false if not).\n\nNote\n\nThis compares space groups rather than space group types, i.e. the  comparison assumes a matching setting choice between H and G. To compare space  group types with different conventional settings, they must first be transformed to a shared setting.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.israyrep","page":"API","title":"Crystalline.israyrep","text":"israyrep(lgir::LGIrrep, αβγ=nothing) -> (::Bool, ::Matrix)\n\nComputes whether a given little group irrep ir is a ray representation  by computing the coefficients αᵢⱼ in DᵢDⱼ=αᵢⱼDₖ; if any αᵢⱼ differ  from unity, we consider the little group irrep a ray representation (as opposed to the simpler \"vector\" representations where DᵢDⱼ=Dₖ). The function returns a boolean (true => ray representation) and the coefficient matrix αᵢⱼ.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.issubgroup-Union{Tuple{T}, Tuple{D}, Tuple{T,T}} where T<:AbstractArray{SymOperation{D},1} where D","page":"API","title":"Crystalline.issubgroup","text":"issubgroup(opsᴳ::T, opsᴴ::T) where T<:AbstractVector{SymOperation{D}} --> Bool\n\nDetermine whether the operations in group H are a subgroup of the group G (each with  operations opsᴳ and opsᴴ, respectively), i.e. whether HG. Specifically, this requires that G and H are both groups and that for every hH there exists an element gG such that h=g.\n\nReturns a Boolean answer (true if normal, false if not).\n\nNote\n\nThis compares space groups rather than space group types, i.e. the comparison assumes a matching setting choice between H and G. To compare space group types with different conventional settings, they must first be transformed to a shared setting.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.issymmorph","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(sgnum::Integer, D::Integer=3) --> Bool\n\nReturn whether the space group with number sgnum and dimensionality D is symmorphic  (true) or nonsymmorphic (false).\n\nEquivalent to issymmorph(spacegroup(sgnum, D)) but uses memoization for performance.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.issymmorph-Tuple{Union{LittleGroup, SpaceGroup}}","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(sg::AbstractGroup) --> Bool\n\nReturn whether a given space group sg is symmorphic (true) or nonsymmorphic (false).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.issymmorph-Union{Tuple{D}, Tuple{SymOperation{D},Char}} where D","page":"API","title":"Crystalline.issymmorph","text":"issymmorph(op::SymOperation, cntr::Char) --> Bool\n\nReturn whether a given symmetry operation op is symmorphic (true) or nonsymmorphic (false). \n\nThe operation is assumed provided in conventional basis with centering type cntr:  checking symmorphism is then equivalent to checking whether the operation's translation part is zero or a lattice vector in the associated primitive basis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.iuc","page":"API","title":"Crystalline.iuc","text":"iuc(sgnum::Integer, D::Integer=3) --> String\n\nReturns the IUC (International Union of Crystallography) notation for space group number sgnum and dimensionality D, as used in the International Tables of Crystallography.  The notation is sometimes also known as the Hermann-Mauguin notation; the functionality is consequently aliased by hermannmauguin(sgnum, D).  IUC/Hermann-Mauguin notation applies in one, two, and three-dimensions.\n\nFor more information, see https://en.wikipedia.org/wiki/Hermann%E2%80%93Mauguin_notation.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.levelsetlattice","page":"API","title":"Crystalline.levelsetlattice","text":"levelsetlattice(sgnum::Integer, D::Integer=2, idxmax::NTuple=ntuple(i->2,D))\n    --> UnityFourierLattice{D}\n\nCompute a \"neutral\"/uninitialized Fourier lattice basis, a UnityFourierLattice, consistent with the symmetries of the space group sgnum in dimension D. The resulting lattice flat is expanded in a Fourier basis split into symmetry-derived orbits, with intra-orbit  coefficients constrained by the symmetries of the space-group. The inter-orbit coefficients are, however, free and unconstrained.\n\nThe Fourier resolution along each reciprocal lattice vector is controlled by idxmax: e.g., if D = 2 and idxmax = (2, 3), the resulting Fourier lattice may contain  reciprocal lattice vectors (k₁, k₂) with k₁∈[0,±1,±2] and k₂∈[0,±1,±2,±3], referred  to a 𝐆-basis.\n\nThis \"neutral\" lattice can, and usually should, be subsequently modulated by modulate (modulates the inter-orbit coefficients, which will often eliminate symmetries that may remain in the \"neutral\" configuration, where all inter-orbit coefficients are unity).\n\nExamples\n\nCompute a UnityFourierLattice, modulate it with random inter-orbit coefficients via modulate, and finally plot it (requires using PyPlot):\n\njulia> uflat = levelsetlattice(16, 2)\njulia> flat  = modulate(uflat)\njulia> Rs    = directbasis(16, 2) \njulia> plot(flat, Rs)\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.matrix","page":"API","title":"Crystalline.matrix","text":"matrix(BRS::BandRepSet[, includedim::Bool=false])\n\nReturn a matrix representation of BRS::BandRepSet, with band representations as columns  and irreps over rows.\n\nFor includedim=true the band filling (i.e. dim.(BRS)) is included as the last row.\n\n\n\n\n\n","category":"function"},{"location":"api/#Crystalline.modulate-Union{Tuple{Crystalline.AbstractFourierLattice{D}}, Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}}}, Tuple{Crystalline.AbstractFourierLattice{D},Union{Nothing, AbstractArray{Complex{Float64},1}},Union{Nothing, Real}}} where D","page":"API","title":"Crystalline.modulate","text":"modulate(flat::UnityFourierLattice{D},\nmodulation::AbstractVector{ComplexF64}=rand(ComplexF64, length(getcoefs(flat))),\nexpon::Union{Nothing, Real}=nothing)\n                        --> ModulatedFourierLattice{D}\n\nDerive a concrete, modulated Fourier lattice from flat, a UnityFourierLattice  struct (that contains the interrelations between orbit coefficients), by  multiplying the \"normalized\" orbit coefficients by a modulation, a complex modulating vector (in general, should be complex; otherwise restores unintended symmetry to the lattice). Distinct modulation vectors produce distinct  realizations of the same lattice described by the original flat. By default, a random complex vector is used.\n\nAn exponent expon can be provided, which introduces a penalty term to short- wavelength features (i.e. high-|G| orbits) by dividing the orbit coefficients by |G|^expon; producing a more \"localized\" and \"smooth\" lattice boundary when expon > 0 (reverse for expon < 0). This basically amounts to a  continuous \"simplifying\" operation on the lattice (it is not necessarily a  smoothing operation; it simply suppresses \"high-frequency\" components). If expon = nothing, no rescaling is performed. \n\nThe normscale(!) methods exists to perform subsequent expon norm-rescaling  of a ModulatedFourierLattice.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.mulliken-Union{Tuple{PGIrrep{D}}, Tuple{D}} where D","page":"API","title":"Crystalline.mulliken","text":"Return the Mulliken label of a point group irrep pgir.\n\nNotes\n\nThis functionality is a simple mapping between the tabulated CDML point group irrep labels and associated Mulliken labels, using the listings at the Bilbao Crystallographic Database [1].\n\nIgnoring subscript, the rough rules associated with assignment of Mulliken labels are:\n\nIrrep dimensionality: \n1D irreps: if a real irrep, assign A or B (B if antisymmetric under a principal  rotation); if a complex irrep, assigned label ¹E or ²E.\n2D irreps: assign label E\n3D irreps: assign label T\nu and g subscripts: if the group contains inversion, indicate whether irrep is symmetric (g ~ gerade) or antisymmetric (ᵤ ~ ungerade) under inversion.\nPrime superscripts: if the group contains a mirror m aligned with a principal  rotation axis, but does not contain inversion, indicate whether irrep is symmetric (′)  or antisymmetric (′′) under this mirror.\nNumeral subscripts: the rules for assignment of numeral subscripts are too too complicated in general - and indeed, we are unaware of a general coherent rule – to describe here.\n\nReferences\n\n[1] Bilbao Crystallographic Database: REPRESENTATIONS PG program.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.normscale!-Tuple{ModulatedFourierLattice,Real}","page":"API","title":"Crystalline.normscale!","text":"normscale!(flat::ModulatedFourierLattice, expon::Real) --> ModulatedFourierLattice\n\nIn-place equivalent of normscale: changes flat.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.normscale-Tuple{ModulatedFourierLattice,Real}","page":"API","title":"Crystalline.normscale","text":"normscale(flat::ModulatedFourierLattice, expon::Real) --> ModulatedFourierLattice\n\nApplies subsequent norm-rescaling via expon; see detailed description  in modulate. An in-place variant is provided as normscale!.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.orbit-Tuple{AbstractArray{var\"#s138\",1} where var\"#s138\"<:(AbstractArray{var\"#s137\",2} where var\"#s137\"<:Real),AbstractArray{var\"#s136\",1} where var\"#s136\"<:Real}","page":"API","title":"Crystalline.orbit","text":"orbit(Ws, x)\n\nComputes the orbit of x under a set of point-group operations Ws, i.e. computes the set {gx | g∈G} where g denotes elements of the group G composed of all operations in Ws (possibly iterated, to ensure full coverage).\n\nAt the moment, we only consider point group operations; i.e. there are  no nonsymmorphic Ws parts. \n\nIt is important that Ws and x are given in the same basis. \n\n[W' = PWP⁻¹ if the basis change is from coordinates r to r' = Pr, corresponding  to a new set of basis vectors (x̂')ᵀ=x̂ᵀP; e.g., when going from a direct basis representation to a Cartesian one, the basis change matrix is P = [R₁ R₂ R₃], with Rᵢ inserted as column vectors]\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.pointgroup-Union{Tuple{AbstractArray{SymOperation{D},1}}, Tuple{D}} where D","page":"API","title":"Crystalline.pointgroup","text":"pointgroup(ops:AbstractVector{SymOperation{D}})\npointgroup(sg::AbstractGroup)\n\nComputes the point group associated with a space group sg (characterized by a set of operators ops, which, jointly with lattice translations generate  the space group), obtained by \"taking away\" any translational parts and  then reducing to the resulting unique rotational operations. (technically, in the language of Bradley & Cracknell, this is the so-called isogonal point group of sg; see Sec. 1.5).\n\nReturns a Vector of SymOperations.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.prepare_mpbcalc!-Union{Tuple{D}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real}}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real}, Tuple{IO,Integer,Crystalline.AbstractFourierLattice{D},DirectBasis{D},Union{Nothing, Real},Real,Real,String}} where D","page":"API","title":"Crystalline.prepare_mpbcalc!","text":"prepare_mpbcalc!(...)\n\nFormats a set of parameters that uniquely specify an MPB calculation, given a  space group number sgnum, a Fourier lattice flat, a DirectBasis Rs, a filling fraction filling for flat, interior and exterior (above, below the contour) permittivities εin and εout, as well as a list of k-vectors kvecs, an  identifying tag id (to label the calculation for book-keeping purposes), a  resolution for the MPB calculation res, and a selection of calculation type runtype (\"all\", \"te\", or \"tm\"). The results are written to requested IO io.\n\nOur preferred choice is to write these parameters to a bash file, with a name generated by the mpb_calcname(...) method.\n\nThe options are expected to be fed to the fourier-lattice.ctl file, e.g. through a bash script of the following kind:\n\n    IFS=$'\\n'; # stop command-substitutions from word-splitting at space\n\n    PATH_TO_MPB_EXECUTABLE \\\n        (cat ${calcname}.sh)\n        ctl/fourier-lattice.ctl 2>&1 | tee logs/${calcname}.log\n        \n    unset IFS; # restore usual command-substitution word-splitting practice\n\nwhere PATH_TO_MPB_EXECUTABLE is the path to the MPB executable. Locally, in mpb-ctl we have a file run-fourier-lattice.sh which performs the  above, with calcname specified as an input parameter (assumed to be a subfolder /input/).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractFourierLattice{D},Char}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(flat::AbstractFourierLattice, cntr::Char) --> ::typeof(flat)\n\nGiven flat referred to a conventional basis with centering cntr, compute the derived (but physically equivalent) lattice flat′ referred to the associated primitive basis. \n\nSpecifically, if flat refers to a direct conventional basis Rs  (𝐚 𝐛 𝐜) [with  coordinate vectors 𝐫  (r₁ r₂ r₃)^T] then flat′ refers to a direct primitive basis Rs′  (𝐚 𝐛 𝐜)  (𝐚 𝐛 𝐜)P [with coordinate vectors 𝐫  (r₁ r₂ r₃)^T = P¹𝐫], where P denotes the basis-change matrix obtained from primitivebasismatrix(...).\n\nTo compute the associated primitive basis vectors, see primitivize(::DirectBasis, ::Char) [specifically, Rs′ = primitivize(Rs, cntr)].\n\nExamples\n\nA centered ('c') lattice from plane group 5 in 2D, plotted in its  conventional and primitive basis (requires using PyPlot):\n\njulia> using PyPlot\njulia> sgnum = 5; D = 2; cntr = centering(sgnum, D)  # 'c' (body-centered)\n\njulia> Rs   = directbasis(sgnum, D)     # conventional basis (rectangular)\njulia> flat = levelsetlattice(sgnum, D) # Fourier lattice in basis of Rs\njulia> flat = modulate(flat)            # modulate the lattice coefficients\njulia> plot(flat, Rs)\n\njulia> Rs′   = primitivize(Rs, cntr)    # primitive basis (oblique)\njulia> flat′ = primitivize(flat, cntr)  # Fourier lattice in basis of Rs′\njulia> plot(flat′, Rs′)\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.AbstractVec{D},Char}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(v::T, cntr::Char) where T<:AbstractVec{D} --> v′::T\n\nTransforms a conventional coordinate vector v to a standard primitive basis (specified by the centering type cntr), returning the primitive coordinate vector v′.\n\nNote that a basis change matrix P (as returned e.g. by  Crystalline.primitivebasismatrix) transforms direct coordinate vectors (RVec) as r=P¹r but transforms reciprocal coordinates (KVec) as k = Pᵀk (see e.g. ITA7 Sec. 1.5.1.2 and 1.5.2.1). Recall also the distinction between transforming a basis and the coordinates of a vector.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{Crystalline.Basis{D},Integer}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(Vs::Basis, sgnum::Integer) --> Rs′::Basis\n\nTransforms a conventional Basis (either DirectBasis or ReciprocalBasis) Vs into its primitive equivalent Vs′, provided that its centering differs from the conventional (P or p), by inferring the Bravais type from the space group number sgnum and applying an applying an appropriate (Basis-type specific) transformation. \n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{DirectBasis{D},Char}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(Rs::DirectBasis, cntr::Char) --> Rs′::DirectBasis\n\nTransforms a conventional DirectBasis Rs into its primitive  equivalent Rs′, with the transformation dependent on the centering type cntr (P, I, F, R, A, C, and p, c); for centering P and p, the  conventional and primive bases coincide.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{ReciprocalBasis{D},Char}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(Gs::ReciprocalBasis, cntr::Char) --> Gs′::ReciprocalBasis\n\nCalculates the primitive reciprocal basis associated with an assumed conventional reciprocal basis Gs::ReciprocalBasis with centering type cntr.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.primitivize-Union{Tuple{D}, Tuple{SymOperation{D},Char}, Tuple{SymOperation{D},Char,Bool}} where D","page":"API","title":"Crystalline.primitivize","text":"primitivize(op::SymOperation, cntr::Char, modw::Bool=true) --> SymOperation\n\nTransforms a symmetry operation op = Ww from a conventional cell to a primitive cell (specified by its centering character cntr), then denoted Ww; i.e. performs a basis change op′  Ww = Pp¹WwPp where P and p are the basis change matrix and origin shifts, respectively, of the transformation.\n\nBy default, translation parts of op′, i.e. w are reduced modulo 1 (modw = true); to disable this, set modw = false.\n\nFor additional details, see ITA6 Sec. 1.5.2.3, p. 84.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.realify-Union{Tuple{AbstractArray{LGIrrep{D},1}}, Tuple{D}, Tuple{AbstractArray{LGIrrep{D},1},Bool}} where D","page":"API","title":"Crystalline.realify","text":"realify(lgirs::AbstractVector{<:LGIrrep}, verbose::Bool=false)\n                                                    --> AbstractVector{<:LGIrrep}\n\nFrom lgirs, a vector of LGIrreps, determine the associated (gray) co-representations, i.e. the \"real\", or \"physical\" irreps that are relevant in scenarios with time-reversal symmetry.\n\nFor LGIrrep that are REAL, or that characterize a k-point 𝐤 which is not equivalent to -𝐤 (i.e. its star does not include both 𝐤 and -𝐤; equivalently, the little group includes time-reversal symmetry), the associated co-representations are just the  original irreps themselves.  For PSEUDOREAL and COMPLEX LGIrreps where ±𝐤 are equivalent, the associated co-representations are built from pairs of irreps that \"stick\" together. This method computes this pairing and sets the LGIrrep field iscorep to true, to indicate that the resulting \"paired irrep\" (i.e. the co-representation) should be doubled with  itself (PSEUDOREAL reality) or its complex conjugate (COMPLEX reality).\n\nBackground\n\nFor background, see p. 650-652 (and 622-626 for point groups) in Bradley & Cracknell's book. Their discussion is for magnetic groups (the \"realified\" irreps are really correspond to co-representations of \"gray\" magnetic groups).  Cornwell's book also does a good job of explicating this, as does Inui (p. 296-299).\n\nKeyword arguments\n\nverbose::Bool: if set to true, prints details about mapping from small irrep to small\n\ncorep for each LGIrrep (default: false).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.realify-Union{Tuple{AbstractArray{T,1}}, Tuple{T}} where T<:Crystalline.AbstractIrrep","page":"API","title":"Crystalline.realify","text":"realify(pgirs::AbstractVector{T}) where T<:AbstractIrrep --> Vector{T}\n\nReturn physically real irreps (coreps) from a set of conventional irreps (as produced by e.g. get_pgirreps). Fallback method for point-group-like AbstractIrreps.\n\nExample\n\njulia> pgirs = get_pgirreps(\"4\", Val(3));\njulia> CharacterTable(pgirs)\nCharacterTable{3}: #9 (4)\n───────┬────────────────────\n       │ Γ₁  Γ₂    Γ₃    Γ₄ \n───────┼────────────────────\n     1 │  1   1     1     1\n  2₀₀₁ │  1   1    -1    -1\n 4₀₀₁⁺ │  1  -1   1im  -1im\n 4₀₀₁⁻ │  1  -1  -1im   1im\n───────┴────────────────────\n\njulia> CharacterTable(realify(pgirs))\nCharacterTable{3}: #9 (4)\n───────┬──────────────\n       │ Γ₁  Γ₂  Γ₃Γ₄ \n───────┼──────────────\n     1 │  1   1     2\n  2₀₀₁ │  1   1    -2\n 4₀₀₁⁺ │  1  -1     0\n 4₀₀₁⁻ │  1  -1     0\n───────┴──────────────\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.reciprocalbasis-Union{Tuple{Union{Tuple{Vararg{Array{var\"#s141\",1} where var\"#s141\"<:Real,D}}, DirectBasis{D}}}, Tuple{D}} where D","page":"API","title":"Crystalline.reciprocalbasis","text":"reciprocalbasis(Rs::DirectBasis{D}) --> Gs::ReciprocalBasis{D}\n\nCalculates the reciprocal basis associated with a DirectBasis Rs (alternatively supplied as an NTuple of Vectors). Returns a ReciprocalBasis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.schoenflies-Tuple{Integer}","page":"API","title":"Crystalline.schoenflies","text":"schoenflies(sgnum::Integer) --> String\n\nReturns the Schoenflies notation for a given space group number sgnum. Schoenflies notation only applies to point groups and  space groups, not plane groups, so this notation is only relevant in three dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.seitz-Union{Tuple{SymOperation{D}}, Tuple{D}} where D","page":"API","title":"Crystalline.seitz","text":"seitz(op::SymOperation) --> String\n\nComputes the correponding Seitz notation for a symmetry operation in triplet/xyzt form.\n\nImplementation based on ITA5 Table 11.2.1.1, with 3D point group parts inferred from the trace and determinant of the matrix W in the triplet Ww.\n\ndetW\\trW -3 -2 -1 0 1 2 3\n1   2 3 4 6 1\n-1 -1 -6 -4 -3 m  \n\nwith the elements of the table giving the type of symmetry operation in in Hermann-Mauguin notation. The rotation axis and the rotation sense are  computed following the rules in ITA6 Sec. 1.2.2.4(1)(b-c). The implementation has been checked against the Tables 1.4.2.1-5 of ITA6.\n\nNote that the orientation of axis (i.e. its sign) is not necessarily equal to the orientation picked in those tables; it is a matter of convention, and the conventions have not been explicated in ITA6.\n\n2D operations are treated by the same procedure, by elevation in a third dimension; 1D operations by a simple inspection of sign.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.spacegroup-Union{Tuple{Integer}, Tuple{D}, Tuple{Integer,Val{D}}} where D","page":"API","title":"Crystalline.spacegroup","text":"spacegroup(sgnum::Integer, D::Integer=3) --> SpaceGroup{D}\n\nReturn the space group symmetry operations for a given space group number sgnum and  dimensionality D as a SpaceGroup{D}. The returned symmetry operations are specified relative to the conventional basis vectors, i.e. are not necessarily primitive (see centering). If desired, operations for the primitive unit cell can subsequently be generated using  primitivize or Crystalline.reduce_ops.\n\nThe default choices for the conventional basis vectors follow the conventions of the Bilbao Crystallographic Server (or, equivalently, the International Tables of Crystallography),  which are:\n\nUnique axis b (cell choice 1) for space groups within the monoclinic system.\nObverse triple hexagonal unit cell for rhombohedral space groups.\nOrigin choice 2: inversion center at (0,0,0). (relevant for the centrosymmetric space groups where there are two origin choices, in the orthorhombic, tetragonal and cubic  systems)\n\nSee also directbasis.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.subduction_count-Union{Tuple{T}, Tuple{T,T}, Tuple{T,T,Union{Nothing, Array{var\"#s138\",1} where var\"#s138\"<:Real}}} where T<:Crystalline.AbstractIrrep","page":"API","title":"Crystalline.subduction_count","text":"subduction_count(Dᴳᵢ, Dᴴⱼ[, αβγᴴⱼ]) --> Int64\n\nFor two groups G and H, where H is a subgroup of G, i.e. G>H, with associated  irreducible representations Dᴳᵢ(g) and Dᴴⱼ(g) for elements gG and hHG, compute the compatibility relation between the two irreps from the subduction reduction formula (or \"magic\" formula/Schur orthogonality relation): this is essentially how many times nᴳᴴᵢⱼ the subduced representation DᴳᵢH contains the irrep Dᴴⱼ;  in other words, this gives the compatibility between the two irreps.\n\nOptionally, a vector αβγᴴⱼ may be provided, to evaluate the characters/irreps  of Dᴳᵢ at a concrete value of αβγ. This is e.g. meaningful for LGIrreps at non- special k-vectors. Defaults to nothing.\n\nThe reduction formula [e.g. Eq. (15) of https://arxiv.org/pdf/1706.09272.pdf] is:\n\nnᴳᴴᵢⱼ = H^-1_h χ^G_i(h)χ^H_j(h)*\n\nAs an example, consider space group 207 and the two compatible k-vectors  Γ (a point) and Σ (a line):\n\nlgirsd  = get_lgirreps(207, Val(3));\nΓ_lgirs = lgirsd[\"Γ\"]; # at Γ ≡ [0.0, 0.0, 0.0]\nΣ_lgirs = lgirsd[\"Σ\"]; # at Σ ≡ [α, α, 0.0]\n\nWe can test their compatibility like so:\n\n[[subduction_count(Γi, Σj) for Γi in Γ_lgirs] for Σj in Σ_lgirs]\n> # Γ₁ Γ₂ Γ₃ Γ₄ Γ₅\n>  [ 1, 0, 1, 1, 2] # Σ₁\n>  [ 0, 1, 1, 2, 1] # Σ₂\n\nThis entails the following compatibility relations between irreps at Γ and Σ:\n\nCompatibility relation Degeneracies\nΓ₁ → Σ₁ 1 → 1\nΓ₂ → Σ₂ 1 → 1\nΓ₃ → Σ₁ + Σ₂ 2 → 1 + 1\nΓ₄ → Σ₁ + 2Σ₂ 3 → 1 + 2\nΓ₅ → 2Σ₁ + Σ₂ 3 → 2 + 1\n\nwhere, in this case, all the small irreps are one-dimensional.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.transform-Union{Tuple{D}, Tuple{KVec{D},AbstractArray{var\"#s140\",2} where var\"#s140\"<:Real}} where D","page":"API","title":"Crystalline.transform","text":"transform(v::T, P::AbstractMatrix) where T<:AbstractVec --> v′::T\n\nReturn a transformed coordinate vector v′ from an original coordinate vector v using a basis change matrix P.\n\nNote that a basis change matrix P transforms direct coordinate vectors (RVec) as r=P¹r but transforms reciprocal coordinates (KVec) as k = Pᵀk (see e.g. ITA7 Sec. 1.5.1.2 and 1.5.2.1).\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.transform-Union{Tuple{D}, Tuple{SymOperation{D},AbstractArray{var\"#s61\",2} where var\"#s61\"<:Real}, Tuple{SymOperation{D},AbstractArray{var\"#s37\",2} where var\"#s37\"<:Real,Union{Nothing, AbstractArray{var\"#s25\",1} where var\"#s25\"<:Real}}, Tuple{SymOperation{D},AbstractArray{var\"#s24\",2} where var\"#s24\"<:Real,Union{Nothing, AbstractArray{var\"#s18\",1} where var\"#s18\"<:Real},Bool}} where D","page":"API","title":"Crystalline.transform","text":"transform(op::SymOperation, P::Matrix{<:Real}, \n          p::Union{Vector{<:Real}, Nothing}=nothing,\n          modw::Bool=true)                          --> SymOperation\n\nTransforms a op = Ww by a rotation matrix P and a translation vector p (can be nothing for zero-translations), producing a new symmetry operation  op′ = Ww (see ITA6 Sec. 1.5.2.3):\n\nWw = Pp^-1WwPp\n\nwith\n\nW = P^-1WP and w = P^-1(w+Wp-p)\n\nBy default, the translation part of op′, i.e. w, is reduced to the range 01),  i.e. computed modulo 1. This can be disabled by setting modw = false (default, modw = true).\n\nSee also primitivize and conventionalize.\n\n\n\n\n\n","category":"method"},{"location":"api/#Crystalline.wyck-Tuple{SiteGroup}","page":"API","title":"Crystalline.wyck","text":"wyck(g::SiteGroup) -> WyckPos{D} where D\n\n\nReturn the Wyckoff position associated with a SiteGroup.\n\n\n\n\n\n","category":"method"},{"location":"api/#Exported-constants","page":"API","title":"Exported constants","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"Modules = [Crystalline]\nPrivate = false\nOrder   = [:constant]","category":"page"},{"location":"groups/#Groups","page":"Groups","title":"Groups","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"All groups in Crystalline are concrete instances of the abstract supertype AbstractGroup{D}, referring to a group in D dimensions. AbstractGroup{D} is itself a subtype of AbstractVector{SymOperation{D}}. Crystalline currently supports four group types: SpaceGroup, LittleGroup, PointGroup, and SiteGroup.","category":"page"},{"location":"groups/#Space-groups","page":"Groups","title":"Space groups","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"The one, two, and three-dimensional space groups are accessible via spacegroup, which takes the space group number sgnum and dimensino D as input (ideally, the dimension is provided as a Val{D} for the sake of type stability) and returns a SpaceGroup{D} structure:","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"using Crystalline\n\nD     = 3  # dimension\nsgnum = 16 # space group number (≤2 in 1D, ≤17 in 2D, ≤230 in 3D)\nsg    = spacegroup(sgnum, D) # where practical, `spacegroup` should be called with a `Val{D}` dimension to ensure type stability; here we have D::Int instead for simplicity","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"By default, the returned operations are given in the conventional setting of the International Tables of Crystallography, Volume A (ITA). Conversion to the standard primitive lattices can be accomplished via primitive.","category":"page"},{"location":"groups/#Multiplication-tables","page":"Groups","title":"Multiplication tables","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"We can compute the multiplication table of a space group (under the previously defined notion of operator composition) using MultTable:","category":"page"},{"location":"groups/","page":"Groups","title":"Groups","text":"MultTable(sg)","category":"page"},{"location":"groups/#Symmorphic-vs.-nonsymorphic-space-groups","page":"Groups","title":"Symmorphic vs. nonsymorphic space groups","text":"","category":"section"},{"location":"groups/","page":"Groups","title":"Groups","text":"A given space group can be tested for whether or not it is symmorphic via issymmorph.","category":"page"},{"location":"lattices/#Symmetry-respecting-isosurface-lattices","page":"Lattices","title":"Symmetry-respecting isosurface lattices","text":"","category":"section"},{"location":"bandreps/#Elementary-band-representations","page":"Band representations","title":"Elementary band representations","text":"","category":"section"},{"location":"bravais/#Bravais-types-and-basis-systems","page":"Bravais types & bases","title":"Bravais types and basis systems","text":"","category":"section"},{"location":"#Crystalline.jl","page":"Home","title":"Crystalline.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for Crystalline.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\"api.md\",\n         \"operations.md\",\n         \"groups.md\",\n         \"irreps.md\",\n         \"bravais.md\",\n         \"bandreps.md\",\n         \"lattices.md\",\n         \"api.md\"]","category":"page"},{"location":"irreps/#Irreducible-representations","page":"Irreps","title":"Irreducible representations","text":"","category":"section"},{"location":"irreps/","page":"Irreps","title":"Irreps","text":"TODO","category":"page"}]
}
